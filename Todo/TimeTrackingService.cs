using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Todo
{
    public enum TimeEventType { Open, Close }

    // DayType moved here so it can be shared and persisted
    public enum DayType { WorkingDay, Weekend, PublicHoliday, Vacation, TimeInLieu, Other }

    public class TimeEvent
    {
        public DateTime Timestamp { get; set; }
        public TimeEventType Type { get; set; }
        // mark events generated by applying a template so dialogs can ignore them when determining earliest real opens
        public bool Generated { get; set; }
    }

    public class TimeTemplate
    {
        public string Id { get; set; } = Guid.NewGuid().ToString();
        public DateTime StartDate { get; set; } = DateTime.Today;
        public DateTime? EndDate { get; set; } = null; // null = ongoing
        // Human-friendly template name (shown in lists)
        public string TemplateName { get; set; } = "Employment Position (Location)";
        // Employment-specific fields
        public string EmploymentPosition { get; set; } = "";
        public string EmploymentLocation { get; set; } = "";
        // Backwards-compatible property for older saved files / code
        public string JobDescription { get { return TemplateName; } set { TemplateName = value; } }
        public string Location { get { return EmploymentLocation; } set { EmploymentLocation = value; } }
        // Hours for Monday(0) .. Sunday(6)
        public double[] HoursPerWeekday { get; set; } = new double[7] {8,8,8,8,8,0,0};

        // New: standard times and lunch break length (TimeSpan)
        public TimeSpan StandardStart { get; set; } = TimeSpan.FromHours(9);
        public TimeSpan LunchBreak { get; set; } = TimeSpan.FromHours(0.5);
        public TimeSpan StandardEnd { get; set; } = TimeSpan.FromHours(17);

        public bool AppliesTo(DateTime d)
        {
            var date = d.Date;
            if (date < StartDate.Date) return false;
            if (EndDate.HasValue && date > EndDate.Value.Date) return false;
            return true;
        }
    }

    // Simple per-day overrides persisted between sessions
    public class DayOverride
    {
        public DateTime Date { get; set; }
        public string Position { get; set; } = string.Empty;
        public string Location { get; set; } = string.Empty;
        public string PhysicalLocation { get; set; } = string.Empty;
        // New: target hours override for the day
        public double? TargetHours { get; set; }
        // Optional persisted DayType override
        public DayType? DayType { get; set; }
    }

    public class DaySummary
    {
        public DateTime Date { get; set; }
        public TimeSpan? OpenTime { get; set; }
        public TimeSpan? CloseTime { get; set; }
        public double? WorkedHours { get; set; }
        public double StandardHours { get; set; }
        public double? DeltaHours { get; set; }
    }

    public class TimeTrackingService
    {
        // All persisted user data files will be stored under the user's My Documents folder in CHillSW/TodoBMW
        private static readonly string DataDirectory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "CHillSW", "TodoBMW");

        // keep individual file name constants for clarity, but use full paths for IO
        private const string AccountsFileName = "timetracking_accounts.json";
        private const string AccountsLogFileName = "timetracking_accountlog.json";
        private const string EventsFileName = "timetracking_events.json";
        private const string TemplatesFileName = "timetracking_templates.json";
        private const string OverridesFileName = "timetracking_overrides.json";
        private const string ShiftsFileName = "timetracking_shifts.json";
        private const string LocationColorsFileName = "timetracking_locationcolors.json";

        private static readonly string AccountsFile = Path.Combine(DataDirectory, AccountsFileName);
        private static readonly string AccountsLogFile = Path.Combine(DataDirectory, AccountsLogFileName);
        private static readonly string EventsFile = Path.Combine(DataDirectory, EventsFileName);
        private static readonly string TemplatesFile = Path.Combine(DataDirectory, TemplatesFileName);
        private static readonly string OverridesFile = Path.Combine(DataDirectory, OverridesFileName);
        private static readonly string ShiftsFile = Path.Combine(DataDirectory, ShiftsFileName);
        private static readonly string LocationColorsFile = Path.Combine(DataDirectory, LocationColorsFileName);

        // Ensure data directory exists before any IO
        static TimeTrackingService()
        {
            try
            {
                Directory.CreateDirectory(DataDirectory);
            }
            catch { }
        }

        private AccountState _accounts = new AccountState { TILOffset = 0.0, HolidayOffset = 0.0 };
        private List<TimeEvent> _events = new List<TimeEvent>();
        private List<TimeTemplate> _templates = new List<TimeTemplate>();
        private List<DayOverride> _overrides = new List<DayOverride>();
        private List<Shift> _shifts = new List<Shift>();
        private List<AccountLogEntry> _accountLog = new List<AccountLogEntry>();
        private Dictionary<string, string> _locationColors = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        public static TimeTrackingService Instance { get; } = new TimeTrackingService();

        private static JsonSerializerOptions TemplateJsonOptions => new JsonSerializerOptions
        {
            WriteIndented = true,
            Converters = { new TimeSpanJsonConverter() }
        };

        private TimeTrackingService()
        {
            Load();
        }

        private void Load()
        {
            try
            {
                if (File.Exists(EventsFile))
                {
                    var j = File.ReadAllText(EventsFile);
                    var items = JsonSerializer.Deserialize<List<TimeEvent>>(j, TemplateJsonOptions);
                    if (items != null) _events = items.OrderBy(x=>x.Timestamp).ToList();
                }
            }
            catch { }

            try
            {
                if (File.Exists(TemplatesFile))
                {
                    var j = File.ReadAllText(TemplatesFile);
                    var items = JsonSerializer.Deserialize<List<TimeTemplate>>(j, TemplateJsonOptions);
                    if (items != null) _templates = items;
                }
            }
            catch { }

            try
            {
                if (File.Exists(OverridesFile))
                {
                    var j = File.ReadAllText(OverridesFile);
                    var items = JsonSerializer.Deserialize<List<DayOverride>>(j, TemplateJsonOptions);
                    if (items != null) _overrides = items;
                }
            }
            catch { }

            try
            {
                if (File.Exists(ShiftsFile))
                {
                    var j = File.ReadAllText(ShiftsFile);
                    var items = JsonSerializer.Deserialize<List<Shift>>(j, TemplateJsonOptions);
                    if (items != null) _shifts = items;
                }
            }
            catch { }

            try
            {
                if (File.Exists(AccountsFile))
                {
                    var j = File.ReadAllText(AccountsFile);
                    var a = JsonSerializer.Deserialize<AccountState>(j);
                    if (a != null) _accounts = a;
                }
            }
            catch { }

            try
            {
                if (File.Exists(AccountsLogFile))
                {
                    var j = File.ReadAllText(AccountsLogFile);
                    var items = JsonSerializer.Deserialize<List<AccountLogEntry>>(j);
                    if (items != null) _accountLog = items;
                }
            }
            catch { }

            try
            {
                if (File.Exists(LocationColorsFile))
                {
                    var j = File.ReadAllText(LocationColorsFile);
                    var dict = JsonSerializer.Deserialize<Dictionary<string, string>>(j);
                    if (dict != null) _locationColors = new Dictionary<string, string>(dict, StringComparer.OrdinalIgnoreCase);
                }
            }
            catch { }
        }

        private void SaveEvents()
        {
            try
            {
                var j = JsonSerializer.Serialize(_events, TemplateJsonOptions);
                File.WriteAllText(EventsFile, j);
            }
            catch { }
        }

        private void SaveTemplates()
        {
            try
            {
                var j = JsonSerializer.Serialize(_templates, TemplateJsonOptions);
                File.WriteAllText(TemplatesFile, j);
            }
            catch { }
        }

        private void SaveOverrides()
        {
            try
            {
                var j = JsonSerializer.Serialize(_overrides, TemplateJsonOptions);
                File.WriteAllText(OverridesFile, j);
            }
            catch { }
        }

        private void SaveShifts()
        {
            try
            {
                var j = JsonSerializer.Serialize(_shifts, TemplateJsonOptions);
                File.WriteAllText(ShiftsFile, j);
            }
            catch { }
        }

        private void SaveAccounts()
        {
            try
            {
                var j = JsonSerializer.Serialize(_accounts, new JsonSerializerOptions { WriteIndented = true });
                File.WriteAllText(AccountsFile, j);
            }
            catch { }
        }

        private void SaveAccountLog()
        {
            try
            {
                var j = JsonSerializer.Serialize(_accountLog, new JsonSerializerOptions { WriteIndented = true });
                File.WriteAllText(AccountsLogFile, j);
            }
            catch { }
        }

        private void SaveLocationColors()
        {
            try
            {
                var j = JsonSerializer.Serialize(_locationColors, new JsonSerializerOptions { WriteIndented = true });
                File.WriteAllText(LocationColorsFile, j);
            }
            catch { }
        }

        public AccountState GetAccountState()
        {
            return _accounts ?? new AccountState { TILOffset = 0.0, HolidayOffset = 0.0 };
        }

        public void SetAccountState(AccountState a)
        {
            if (a == null) return;
            _accounts = a;
            SaveAccounts();
        }

        public void RecordOpen()
        {
            try
            {
                _events.Add(new TimeEvent { Timestamp = DateTime.Now, Type = TimeEventType.Open, Generated = false });
                SaveEvents();
            }
            catch { }
        }

        public void RecordClose()
        {
            try
            {
                _events.Add(new TimeEvent { Timestamp = DateTime.Now, Type = TimeEventType.Close, Generated = false });
                SaveEvents();
            }
            catch { }
        }

        public IReadOnlyList<TimeEvent> GetEvents() => _events.AsReadOnly();

        public IReadOnlyList<TimeTemplate> GetTemplates() => _templates.AsReadOnly();

        public IReadOnlyList<DayOverride> GetOverrides() => _overrides.AsReadOnly();

        public IReadOnlyList<Shift> GetAllSavedShifts() => _shifts.AsReadOnly();

        public IEnumerable<Shift> GetShiftsForDate(DateTime date)
        {
            return _shifts.Where(s => s.Date.Date == date.Date).ToList();
        }

        public void UpsertShiftsForDate(DateTime date, IEnumerable<Shift> shifts)
        {
            try
            {
                _shifts.RemoveAll(s => s.Date.Date == date.Date);
                foreach (var s in shifts)
                {
                    // ensure date
                    s.Date = date.Date;
                    _shifts.Add(s);
                }
                SaveShifts();
            }
            catch { }
        }

        public DayOverride GetOverrideForDate(DateTime date)
        {
            return _overrides.FirstOrDefault(o => o.Date.Date == date.Date);
        }

        public void UpsertOverride(DateTime date, string position, string location, string physicalLocation, double? targetHours = null, DayType? dayType = null)
        {
            try
            {
                var existing = _overrides.FirstOrDefault(o => o.Date.Date == date.Date);
                if (existing == null)
                {
                    existing = new DayOverride
                    {
                        Date = date.Date,
                        Position = position ?? string.Empty,
                        Location = location ?? string.Empty,
                        PhysicalLocation = physicalLocation ?? string.Empty,
                        TargetHours = targetHours,
                        DayType = dayType
                    };
                    _overrides.Add(existing);
                }
                else
                {
                    existing.Position = position ?? string.Empty;
                    existing.Location = location ?? string.Empty;
                    existing.PhysicalLocation = physicalLocation ?? string.Empty;
                    existing.TargetHours = targetHours ?? existing.TargetHours;
                    // only update DayType if caller provided a value; otherwise preserve existing override
                    if (dayType.HasValue)
                        existing.DayType = dayType.Value;
                }
                SaveOverrides();
            }
            catch { }
        }

        public void UpsertTemplate(TimeTemplate t)
        {
            var found = _templates.FirstOrDefault(x => x.Id == t.Id);
            if (found == null)
            {
                _templates.Add(t);
            }
            else
            {
                found.StartDate = t.StartDate;
                found.EndDate = t.EndDate;
                found.JobDescription = t.JobDescription;
                found.Location = t.Location;
                found.HoursPerWeekday = t.HoursPerWeekday;
                // copy new fields
                found.StandardStart = t.StandardStart;
                found.LunchBreak = t.LunchBreak;
                found.StandardEnd = t.StandardEnd;
            }
            SaveTemplates();
        }

        public bool RemoveTemplate(string id)
        {
            var found = _templates.FirstOrDefault(x => x.Id == id);
            if (found == null) return false;
            _templates.Remove(found);
            SaveTemplates();
            return true;
        }

        public List<DaySummary> GetDaySummaries(DateTime from, DateTime to)
        {
            var result = new List<DaySummary>();
            // events already ordered
            var events = _events.Where(e => e.Timestamp.Date >= from.Date && e.Timestamp.Date <= to.Date).OrderBy(e => e.Timestamp).ToList();

            // For each date in range, find first Open on that date and last Close on that date
            for (var d = from.Date; d <= to.Date; d = d.AddDays(1))
            {
                var opens = _events.Where(e => e.Type == TimeEventType.Open && e.Timestamp.Date == d).OrderBy(e => e.Timestamp).ToList();
                var closes = _events.Where(e => e.Type == TimeEventType.Close && e.Timestamp.Date == d).OrderBy(e => e.Timestamp).ToList();
                TimeSpan? openTs = null;
                TimeSpan? closeTs = null;
                double? worked = null;
                if (opens.Count > 0 && closes.Count > 0)
                {
                    openTs = opens.First().Timestamp.TimeOfDay;
                    closeTs = closes.Last().Timestamp.TimeOfDay;
                    var openDt = opens.First().Timestamp;
                    var closeDt = closes.Last().Timestamp;
                    if (closeDt > openDt)
                        worked = (closeDt - openDt).TotalHours;
                }

                // find applicable template and standard hours
                double std = 0;
                var temp = _templates.FirstOrDefault(t => t.AppliesTo(d));
                if (temp != null)
                {
                    // Map DayOfWeek to index (Mon=0..Sun=6)
                    int idx = ((int)d.DayOfWeek + 6) % 7; // Monday=0
                    if (temp.HoursPerWeekday != null && temp.HoursPerWeekday.Length == 7)
                        std = temp.HoursPerWeekday[idx];
                }

                result.Add(new DaySummary
                {
                    Date = d,
                    OpenTime = openTs,
                    CloseTime = closeTs,
                    WorkedHours = worked,
                    StandardHours = std,
                    DeltaHours = worked.HasValue ? (worked.Value - std) : (double?)null
                });
            }

            return result;
        }

        // Apply template by adding Open/Close events for each date in the template range. If overwriteExisting is true, remove existing open/close events for a date before adding.
        public int ApplyTemplate(TimeTemplate t, bool overwriteExisting = false)
        {
            if (t == null) return 0;
            var end = (t.EndDate ?? DateTime.Today).Date;
            int added = 0;
            for (var d = t.StartDate.Date; d <= end; d = d.AddDays(1))
            {
                // Map DayOfWeek to index (Mon=0..Sun=6)
                int idx = ((int)d.DayOfWeek + 6) % 7;
                // skip days that template defines as 0 hours
                if (t.HoursPerWeekday != null && t.HoursPerWeekday.Length == 7 && t.HoursPerWeekday[idx] == 0) continue;

                var existingEvents = _events.Where(e => e.Timestamp.Date == d && (e.Type == TimeEventType.Open || e.Type == TimeEventType.Close)).ToList();
                if (existingEvents.Any())
                {
                    if (!overwriteExisting)
                        continue; // skip days with any existing events
                    // remove existing open/close events for this date
                    foreach (var ex in existingEvents)
                        _events.Remove(ex);
                }

                var openDt = d.Add(t.StandardStart);
                var closeDt = d.Add(t.StandardEnd);
                if (closeDt <= openDt) continue;

                _events.Add(new TimeEvent { Timestamp = openDt, Type = TimeEventType.Open, Generated = true });
                _events.Add(new TimeEvent { Timestamp = closeDt, Type = TimeEventType.Close, Generated = true });
                added += 1;
            }

            if (added > 0)
            {
                _events = _events.OrderBy(x => x.Timestamp).ToList();
                SaveEvents();
            }

            return added;
        }

        // New: Apply a template and also persist per-day overrides (position, location, physical location and target hours)
        // This will iterate the template date range and for each applicable day (hours > 0) will upsert a DayOverride using the template's employment/location fields
        public int ApplyTemplateWithOverrides(TimeTemplate t, bool overwriteExistingEvents = false, bool overwriteOverrides = true)
        {
            if (t == null) return 0;
            int appliedDays = 0;
            var end = (t.EndDate ?? DateTime.Today).Date;

            // First, apply open/close events (this will respect overwriteExistingEvents)
            var addedEvents = ApplyTemplate(t, overwriteExisting: overwriteExistingEvents);

            // Then, for each day in the range, set per-day overrides (position/location/physical/targethours)
            for (var d = t.StartDate.Date; d <= end; d = d.AddDays(1))
            {
                int idx = ((int)d.DayOfWeek + 6) % 7;
                // skip days with 0 hours
                if (t.HoursPerWeekday != null && t.HoursPerWeekday.Length == 7 && t.HoursPerWeekday[idx] == 0) continue;

                // If overwriteOverrides is false and an override already exists, skip
                var existing = _overrides.FirstOrDefault(o => o.Date.Date == d);
                if (existing != null && !overwriteOverrides)
                {
                    // Still count if events were added for the date
                    appliedDays++;
                    continue;
                }

                try
                {
                    // Use EmploymentLocation as physical location by default
                    var phys = !string.IsNullOrWhiteSpace(existing?.PhysicalLocation) ? existing.PhysicalLocation : t.EmploymentLocation;
                    UpsertOverride(d, t.EmploymentPosition ?? string.Empty, t.EmploymentLocation ?? string.Empty, phys ?? string.Empty, t.HoursPerWeekday?[idx], null);

                    // Also apply a synthetic shift using the template's standard times and lunch break.
                    // If there are existing saved shifts for this date and overwriteExistingEvents is false, do not replace them.
                    var savedShifts = _shifts.Where(s => s.Date.Date == d).ToList();
                    if (!savedShifts.Any() || overwriteExistingEvents)
                    {
                        var openDt = d.Add(t.StandardStart);
                        var closeDt = d.Add(t.StandardEnd);
                        if (closeDt > openDt)
                        {
                            var shift = new Shift
                            {
                                Date = d,
                                Start = t.StandardStart,
                                End = t.StandardEnd,
                                LunchBreak = t.LunchBreak,
                                Description = "(from template)",
                                ManualStartOverride = false,
                                ManualEndOverride = false,
                                DayMode = "auto"
                            };
                            // UpsertShiftsForDate will replace any existing shifts for that date
                            UpsertShiftsForDate(d, new List<Shift> { shift });
                        }
                    }

                    appliedDays++;
                }
                catch { }
            }

            // Save overrides file after batch operation
            try { SaveOverrides(); } catch { }

            // Return count of days for which overrides were applied (not number of events)
            return appliedDays;
        }

        public void AddAccountLogEntry(AccountLogEntry entry)
        {
            try
            {
                if (entry == null) return;
                _accountLog.Add(entry);
                SaveAccountLog();
            }
            catch { }
        }

        // Public helper to reload persisted data from disk into the service singleton
        public void Reload()
        {
            try
            {
                Load();
            }
            catch { }
        }

        public IReadOnlyList<AccountLogEntry> GetAccountLogEntries(DateTime from, DateTime to, string kind = null)
        {
            return _accountLog.Where(a => a.Date.Date >= from.Date && a.Date.Date <= to.Date && (string.IsNullOrEmpty(kind) || a.Kind == kind)).OrderByDescending(a => a.Date).ToList();
        }

        // Location colors management
        public IReadOnlyDictionary<string, string> GetLocationColors() => _locationColors;

        public string GetLocationColor(string location)
        {
            if (string.IsNullOrWhiteSpace(location)) return null;
            return _locationColors.TryGetValue(location, out var hex) ? hex : null;
        }

        public void SetLocationColor(string location, string hex)
        {
            if (string.IsNullOrWhiteSpace(location)) return;
            if (string.IsNullOrWhiteSpace(hex))
            {
                if (_locationColors.Remove(location)) SaveLocationColors();
                return;
            }
            _locationColors[location] = NormalizeHex(hex);
            SaveLocationColors();
        }

        public void RemoveLocationColor(string location)
        {
            if (string.IsNullOrWhiteSpace(location)) return;
            if (_locationColors.Remove(location)) SaveLocationColors();
        }

        public List<string> DiscoverPhysicalLocations()
        {
            var list = new List<string>();
            try
            {
                list.AddRange(_overrides.Where(o => !string.IsNullOrWhiteSpace(o.PhysicalLocation)).Select(o => o.PhysicalLocation));
                list.AddRange(_overrides.Where(o => !string.IsNullOrWhiteSpace(o.Location)).Select(o => o.Location));
                list.AddRange(_templates.Where(t => !string.IsNullOrWhiteSpace(t.EmploymentLocation)).Select(t => t.EmploymentLocation));
            }
            catch { }
            return list.Distinct(StringComparer.OrdinalIgnoreCase).OrderBy(s => s).ToList();
        }

        private static string NormalizeHex(string hex)
        {
            hex = hex.Trim();
            if (!hex.StartsWith("#")) hex = "#" + hex;
            if (hex.Length == 7) return hex.ToUpperInvariant(); // #RRGGBB
            if (hex.Length == 9) return hex.ToUpperInvariant(); // #AARRGGBB
            // try parse named colors? ignore; fallback
            return hex.ToUpperInvariant();
        }
    }

    // Converter to persist TimeSpan values in a robust format (we use "hh:mm"). Also accepts numeric minutes for backward compat.
    internal class TimeSpanJsonConverter : JsonConverter<TimeSpan>
    {
        public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            if (reader.TokenType == JsonTokenType.String)
            {
                var s = reader.GetString();
                if (TimeSpan.TryParse(s, out var ts)) return ts;
                // try parse like hh:mm
                if (TimeSpan.TryParseExact(s, "hh\\:mm", null, out ts)) return ts;
            }
            else if (reader.TokenType == JsonTokenType.Number)
            {
                // treat as minutes
                if (reader.TryGetDouble(out var d)) return TimeSpan.FromMinutes(d);
                if (reader.TryGetInt64(out var l)) return TimeSpan.FromMinutes(l);
            }
            return TimeSpan.Zero;
        }

        public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options)
        {
            // write as "hh:mm"
            writer.WriteStringValue(value.ToString(@"hh\:mm"));
        }
    }

    public class AccountState
    {
        public double TILOffset { get; set; }
        public double HolidayOffset { get; set; }
    }

    public class AccountLogEntry
    {
        public DateTime Date { get; set; }
        public string Kind { get; set; } // "TIL" or "Holiday"
        public double Delta { get; set; }
        public double Balance { get; set; }
        public string Note { get; set; }
        // Optional date that this account change corresponds to (e.g. the vacation day)
        public DateTime? AffectedDate { get; set; }
    }
}
